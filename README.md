# PWrRacingTeam
Zadania na rekrutacje

## Zadanie 1
Jako że jeszcze nie miałem okazji zajmować się takimi rzeczami, a tym bardziej sprawdzić, czy działają, leciałem tutaj mocno na ślepo. Z tego, co się dowiedziałem, pin PA5 jest pinem GPIO, czyli można go skonfigurować jako zwykłe wejście/wyjście cyfrowe (np. do sterowania diodą LED). Widziałem też, że np. TIM1 jest timerem zaawansowanym, więc do tego zadania użyłem TIM2 (general purpose). Na początku ustawiłem HSE w RCC na Crystal/Ceramic Resonator (jest to zewnętrzne źródło, dzięki czemu układ jest samowystarczalny, gdyby jednak chodziło o pracę z innym układem, wybrałbym BYPASS Clock Source). Następnie w Clock Configuration ustawiłem Input frequency na 16 (to było robione trochę "na czuja"). Ustawiłem też PA5 na GPIO_Output, a następnie dowiedziałem się, że diody LED mają własne rezystory, więc ustawiłem opcję No pull dla GPIO Pull-up/Pull-down oraz Low dla Maximum output speed, bo wydaje mi się, że taka prędkość wystarczy dla diody mrugającej z częstotliwością 5 Hz. GPIO mode ustawiłem na Push Pull, ponieważ (chyba) Open Drain może tylko ustawiać stan niski(0), ale nie potrafi sam wymusić wysokiego napięcia. Następnie, konfigurując TIM2, wybrałem Internal Clock (taktowanie z ustawionym wcześniej wewnętrznym zegarem 16MHz). Skoro dioda ma migać z częstotliwością 5Hz, oznacza to 5 cykli na sekundę (200ms), czyli włączenie/wyłączenie co 100ms. Dla 16MHz daje to 16MHz × 0,1s = 1'600'000 tyknięć. Rozłożyłem to na Prescaler = 15 (15 + 1 = 16) i Counter Period = 99999 ((99999 + 1) × (15 + 1) = 1'600'000). Potem dodałem w NVIC Settings przerwanie globalne dla TIM2. Watchdog był dosyć prosty do zaimplementowania (chyba) – zaznaczyłem checkbox, zostawiłem domyślne wartości Prescaler i Reload value, a następnie dodałem funkcję HAL_IWDG_Refresh w głównej pętli. Dzięki temu, jeśli program się zawiesi, mikrokontroler zostanie automatycznie zresetowany. W funkcji HAL_TIM_PeriodElapsedCallback obsłużyłem przerwanie TIM2 i włączenie/wyłączenie diody. Największym problemem w tym zadaniu był chyba brak możliwości (lub umiejętności) sprawdzenia, czy wszystko działa poprawnie, oraz zderzenie z wieloma nowymi pojęciami.

## Zadanie 2
### 1 - Otoczka
Po namyśle (bezowocnym) wykorzystałem pomocy ludzi mądrzejszych (internetu) i zaimplementowałem algorytm QuickHull. Wydawał się najbardziej rozsądny do zrozumienia dla mnie. Z początku chciałem uniknąć rekurencji, ale ostatecznie uległem i użyłem pomocniczej funkcji OtoczkaHelper, by rekurencyjnie wykonać algorytm.
Pierwszym moim pomysłem było wybranie najwyższego punktu i „owijanie” wszystkich punktów, ale albo jest to „średnie” w implementacji, albo ewidentnie brakowało mi wiedzy matematycznej.
Implementacja algorytmu raczej była bezproblemowa. Funkcja zwraca listę punktów należących do otoczki, ponieważ okazały się przydatne do następnego podpunktu.
### 2 - Proste
Jako wejście podaję listę punktów należących do otoczki i następnie je sortuję. Wpadłem na pomysł, że można wykorzystać już znane granice zbioru i lecąc po kolei po bokach, konstruować proste i porównywać z najdalszym punktem (nie trzeba drugiej prostej, gdyż wiadomo, że ma być równoległa i będzie tak samo oddalona po całej długości).
Skonsultowałem pomysł z Claude AI, czy moja „intuicja” mnie nie oszukuje (o dziwo nie), a następnie napisałem kod.
Przez jakiś czas kod miał buga, iterowałem od pierwszego punktu do przedostatniego, biorąc pary punktów, lecz nie uwzględniłem pary pierwszego i ostatniego punktu, czyli pary, która domyka moje „koło”. Po krótkim, ostatecznym teście udało mi się to zauważyć.
### 3 - Najbliższe Punkty
Klasyczne podejście dla wielu problemów wymagających interakcji „każdy z każdym”, czyli dziel i rządź. Tutaj też uległem rekurencji. Nie jestem pewien, czy jest to jakoś bardzo zoptymalizowane, ale powinno być lepsze od O(n²). Problemem okazało się nie zaliczanie punktów pomiędzy podzielonymi sektorami. Troszkę mi to zajęło, żeby zrobić to w sensowny sposób, czyli branie punktów tylko takich które mogłyby być kandydatami na podstawie wcześniej znalezionych punktów.
